{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextPath = void 0;\nvar Util_1 = require(\"../Util\");\nvar Factory_1 = require(\"../Factory\");\nvar Shape_1 = require(\"../Shape\");\nvar Path_1 = require(\"./Path\");\nvar Text_1 = require(\"./Text\");\nvar Validators_1 = require(\"../Validators\");\nvar Global_1 = require(\"../Global\");\nvar EMPTY_STRING = '',\n  NORMAL = 'normal';\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\nvar TextPath = function (_super) {\n  __extends(TextPath, _super);\n  function TextPath(config) {\n    var _this = _super.call(this, config) || this;\n    _this.dummyCanvas = Util_1.Util.createCanvasElement();\n    _this.dataArray = [];\n    _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\n    _this.on('dataChange.konva', function () {\n      this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\n      this._setTextData();\n    });\n    _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\n    if (config && config['getKerning']) {\n      Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\n      _this.kerningFunc(config['getKerning']);\n    }\n    _this._setTextData();\n    return _this;\n  }\n  TextPath.prototype._sceneFunc = function (context) {\n    context.setAttr('font', this._getContextFont());\n    context.setAttr('textBaseline', this.textBaseline());\n    context.setAttr('textAlign', 'left');\n    context.save();\n    var textDecoration = this.textDecoration();\n    var fill = this.fill();\n    var fontSize = this.fontSize();\n    var glyphInfo = this.glyphInfo;\n    if (textDecoration === 'underline') {\n      context.beginPath();\n    }\n    for (var i = 0; i < glyphInfo.length; i++) {\n      context.save();\n      var p0 = glyphInfo[i].p0;\n      context.translate(p0.x, p0.y);\n      context.rotate(glyphInfo[i].rotation);\n      this.partialText = glyphInfo[i].text;\n      context.fillStrokeShape(this);\n      if (textDecoration === 'underline') {\n        if (i === 0) {\n          context.moveTo(0, fontSize / 2 + 1);\n        }\n        context.lineTo(fontSize, fontSize / 2 + 1);\n      }\n      context.restore();\n    }\n    if (textDecoration === 'underline') {\n      context.strokeStyle = fill;\n      context.lineWidth = fontSize / 20;\n      context.stroke();\n    }\n    context.restore();\n  };\n  TextPath.prototype._hitFunc = function (context) {\n    context.beginPath();\n    var glyphInfo = this.glyphInfo;\n    if (glyphInfo.length >= 1) {\n      var p0 = glyphInfo[0].p0;\n      context.moveTo(p0.x, p0.y);\n    }\n    for (var i = 0; i < glyphInfo.length; i++) {\n      var p1 = glyphInfo[i].p1;\n      context.lineTo(p1.x, p1.y);\n    }\n    context.setAttr('lineWidth', this.fontSize());\n    context.setAttr('strokeStyle', this.colorKey);\n    context.stroke();\n  };\n  TextPath.prototype.getTextWidth = function () {\n    return this.textWidth;\n  };\n  TextPath.prototype.getTextHeight = function () {\n    Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n    return this.textHeight;\n  };\n  TextPath.prototype.setText = function (text) {\n    return Text_1.Text.prototype.setText.call(this, text);\n  };\n  TextPath.prototype._getContextFont = function () {\n    return Text_1.Text.prototype._getContextFont.call(this);\n  };\n  TextPath.prototype._getTextSize = function (text) {\n    var dummyCanvas = this.dummyCanvas;\n    var _context = dummyCanvas.getContext('2d');\n    _context.save();\n    _context.font = this._getContextFont();\n    var metrics = _context.measureText(text);\n    _context.restore();\n    return {\n      width: metrics.width,\n      height: parseInt(this.attrs.fontSize, 10)\n    };\n  };\n  TextPath.prototype._setTextData = function () {\n    var that = this;\n    var size = this._getTextSize(this.attrs.text);\n    var letterSpacing = this.letterSpacing();\n    var align = this.align();\n    var kerningFunc = this.kerningFunc();\n    this.textWidth = size.width;\n    this.textHeight = size.height;\n    var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n    this.glyphInfo = [];\n    var fullPathWidth = 0;\n    for (var l = 0; l < that.dataArray.length; l++) {\n      if (that.dataArray[l].pathLength > 0) {\n        fullPathWidth += that.dataArray[l].pathLength;\n      }\n    }\n    var offset = 0;\n    if (align === 'center') {\n      offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n    }\n    if (align === 'right') {\n      offset = Math.max(0, fullPathWidth - textFullWidth);\n    }\n    var charArr = Text_1.stringToArray(this.text());\n    var spacesNumber = this.text().split(' ').length - 1;\n    var p0, p1, pathCmd;\n    var pIndex = -1;\n    var currentT = 0;\n    var getNextPathSegment = function () {\n      currentT = 0;\n      var pathData = that.dataArray;\n      for (var j = pIndex + 1; j < pathData.length; j++) {\n        if (pathData[j].pathLength > 0) {\n          pIndex = j;\n          return pathData[j];\n        } else if (pathData[j].command === 'M') {\n          p0 = {\n            x: pathData[j].points[0],\n            y: pathData[j].points[1]\n          };\n        }\n      }\n      return {};\n    };\n    var findSegmentToFitCharacter = function (c) {\n      var glyphWidth = that._getTextSize(c).width + letterSpacing;\n      if (c === ' ' && align === 'justify') {\n        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n      }\n      var currLen = 0;\n      var attempts = 0;\n      p1 = undefined;\n      while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n        attempts++;\n        var cumulativePathLength = currLen;\n        while (pathCmd === undefined) {\n          pathCmd = getNextPathSegment();\n          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n            cumulativePathLength += pathCmd.pathLength;\n            pathCmd = undefined;\n          }\n        }\n        if (pathCmd === {} || p0 === undefined) {\n          return undefined;\n        }\n        var needNewSegment = false;\n        switch (pathCmd.command) {\n          case 'L':\n            if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n              p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n            } else {\n              pathCmd = undefined;\n            }\n            break;\n          case 'A':\n            var start = pathCmd.points[4];\n            var dTheta = pathCmd.points[5];\n            var end = pathCmd.points[4] + dTheta;\n            if (currentT === 0) {\n              currentT = start + 0.00000001;\n            } else if (glyphWidth > currLen) {\n              currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n            } else {\n              currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n            }\n            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n              currentT = end;\n              needNewSegment = true;\n            }\n            p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n            break;\n          case 'C':\n            if (currentT === 0) {\n              if (glyphWidth > pathCmd.pathLength) {\n                currentT = 0.00000001;\n              } else {\n                currentT = glyphWidth / pathCmd.pathLength;\n              }\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n            } else {\n              currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n            }\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n            p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n            break;\n          case 'Q':\n            if (currentT === 0) {\n              currentT = glyphWidth / pathCmd.pathLength;\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n            } else {\n              currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n            }\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n            p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n            break;\n        }\n        if (p1 !== undefined) {\n          currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        }\n        if (needNewSegment) {\n          needNewSegment = false;\n          pathCmd = undefined;\n        }\n      }\n    };\n    var testChar = 'C';\n    var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n    var lettersInOffset = offset / glyphWidth - 1;\n    for (var k = 0; k < lettersInOffset; k++) {\n      findSegmentToFitCharacter(testChar);\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n      p0 = p1;\n    }\n    for (var i = 0; i < charArr.length; i++) {\n      findSegmentToFitCharacter(charArr[i]);\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n      var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n      var kern = 0;\n      if (kerningFunc) {\n        try {\n          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n        } catch (e) {\n          kern = 0;\n        }\n      }\n      p0.x += kern;\n      p1.x += kern;\n      this.textWidth += kern;\n      var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n      var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n      this.glyphInfo.push({\n        transposeX: midpoint.x,\n        transposeY: midpoint.y,\n        text: charArr[i],\n        rotation: rotation,\n        p0: p0,\n        p1: p1\n      });\n      p0 = p1;\n    }\n  };\n  TextPath.prototype.getSelfRect = function () {\n    if (!this.glyphInfo.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n    var points = [];\n    this.glyphInfo.forEach(function (info) {\n      points.push(info.p0.x);\n      points.push(info.p0.y);\n      points.push(info.p1.x);\n      points.push(info.p1.y);\n    });\n    var minX = points[0] || 0;\n    var maxX = points[0] || 0;\n    var minY = points[1] || 0;\n    var maxY = points[1] || 0;\n    var x, y;\n    for (var i = 0; i < points.length / 2; i++) {\n      x = points[i * 2];\n      y = points[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n    var fontSize = this.fontSize();\n    return {\n      x: minX - fontSize / 2,\n      y: minY - fontSize / 2,\n      width: maxX - minX + fontSize,\n      height: maxY - minY + fontSize\n    };\n  };\n  return TextPath;\n}(Shape_1.Shape);\nexports.TextPath = TextPath;\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\nGlobal_1._registerNode(TextPath);\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\nUtil_1.Collection.mapMethods(TextPath);","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","defineProperty","exports","value","TextPath","Util_1","require","Factory_1","Shape_1","Path_1","Text_1","Validators_1","Global_1","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","_super","config","_this","dummyCanvas","Util","createCanvasElement","dataArray","Path","parsePathData","attrs","data","on","_setTextData","warn","kerningFunc","_sceneFunc","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","_hitFunc","p1","colorKey","getTextWidth","textWidth","getTextHeight","textHeight","setText","Text","_getTextSize","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","letterSpacing","align","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","stringToArray","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","getSelfRect","forEach","info","minX","maxX","minY","maxY","min","Shape","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","_registerNode","Factory","addGetterSetter","getNumberValidator","Collection","mapMethods"],"sources":["/Users/UX201446/Documents/GitHub/konva/node_modules/konva/lib/shapes/TextPath.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextPath = void 0;\nvar Util_1 = require(\"../Util\");\nvar Factory_1 = require(\"../Factory\");\nvar Shape_1 = require(\"../Shape\");\nvar Path_1 = require(\"./Path\");\nvar Text_1 = require(\"./Text\");\nvar Validators_1 = require(\"../Validators\");\nvar Global_1 = require(\"../Global\");\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nvar TextPath = (function (_super) {\n    __extends(TextPath, _super);\n    function TextPath(config) {\n        var _this = _super.call(this, config) || this;\n        _this.dummyCanvas = Util_1.Util.createCanvasElement();\n        _this.dataArray = [];\n        _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\n        _this.on('dataChange.konva', function () {\n            this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\n        if (config && config['getKerning']) {\n            Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\n            _this.kerningFunc(config['getKerning']);\n        }\n        _this._setTextData();\n        return _this;\n    }\n    TextPath.prototype._sceneFunc = function (context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    };\n    TextPath.prototype._hitFunc = function (context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    };\n    TextPath.prototype.getTextWidth = function () {\n        return this.textWidth;\n    };\n    TextPath.prototype.getTextHeight = function () {\n        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    };\n    TextPath.prototype.setText = function (text) {\n        return Text_1.Text.prototype.setText.call(this, text);\n    };\n    TextPath.prototype._getContextFont = function () {\n        return Text_1.Text.prototype._getContextFont.call(this);\n    };\n    TextPath.prototype._getTextSize = function (text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    };\n    TextPath.prototype._setTextData = function () {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = Text_1.stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    };\n    TextPath.prototype.getSelfRect = function () {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    };\n    return TextPath;\n}(Shape_1.Shape));\nexports.TextPath = TextPath;\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\nGlobal_1._registerNode(TextPath);\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\nUtil_1.Collection.mapMethods(TextPath);\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,aAAa,GAAG,SAAAA,CAAUC,CAAC,EAAEC,CAAC,EAAE;IAChCF,aAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;MAAEC,SAAS,EAAE;IAAG,CAAC,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;MAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;IAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;MAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC,EAAE,IAAIC,MAAM,CAACK,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,CAAC,EAAEK,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IAAE,CAAC;IACrG,OAAOP,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC9B,CAAC;EACD,OAAO,UAAUD,CAAC,EAAEC,CAAC,EAAE;IACnBF,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASS,EAAEA,CAAA,EAAG;MAAE,IAAI,CAACC,WAAW,GAAGX,CAAC;IAAE;IACtCA,CAAC,CAACO,SAAS,GAAGN,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACU,MAAM,CAACX,CAAC,CAAC,IAAIS,EAAE,CAACH,SAAS,GAAGN,CAAC,CAACM,SAAS,EAAE,IAAIG,EAAE,CAAC,CAAC,CAAC;EACxF,CAAC;AACL,CAAC,CAAE,CAAC;AACJR,MAAM,CAACW,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,QAAQ,GAAG,KAAK,CAAC;AACzB,IAAIC,MAAM,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC/B,IAAIC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AACrC,IAAIE,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACjC,IAAIG,MAAM,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAII,MAAM,GAAGJ,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIK,YAAY,GAAGL,OAAO,CAAC,eAAe,CAAC;AAC3C,IAAIM,QAAQ,GAAGN,OAAO,CAAC,WAAW,CAAC;AACnC,IAAIO,YAAY,GAAG,EAAE;EAAEC,MAAM,GAAG,QAAQ;AACxC,SAASC,SAASA,CAACC,OAAO,EAAE;EACxBA,OAAO,CAACC,QAAQ,CAAC,IAAI,CAACC,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;AAC5C;AACA,SAASC,WAAWA,CAACH,OAAO,EAAE;EAC1BA,OAAO,CAACI,UAAU,CAAC,IAAI,CAACF,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;AAC9C;AACA,IAAId,QAAQ,GAAI,UAAUiB,MAAM,EAAE;EAC9BnC,SAAS,CAACkB,QAAQ,EAAEiB,MAAM,CAAC;EAC3B,SAASjB,QAAQA,CAACkB,MAAM,EAAE;IACtB,IAAIC,KAAK,GAAGF,MAAM,CAACxB,IAAI,CAAC,IAAI,EAAEyB,MAAM,CAAC,IAAI,IAAI;IAC7CC,KAAK,CAACC,WAAW,GAAGnB,MAAM,CAACoB,IAAI,CAACC,mBAAmB,CAAC,CAAC;IACrDH,KAAK,CAACI,SAAS,GAAG,EAAE;IACpBJ,KAAK,CAACI,SAAS,GAAGlB,MAAM,CAACmB,IAAI,CAACC,aAAa,CAACN,KAAK,CAACO,KAAK,CAACC,IAAI,CAAC;IAC7DR,KAAK,CAACS,EAAE,CAAC,kBAAkB,EAAE,YAAY;MACrC,IAAI,CAACL,SAAS,GAAGlB,MAAM,CAACmB,IAAI,CAACC,aAAa,CAAC,IAAI,CAACC,KAAK,CAACC,IAAI,CAAC;MAC3D,IAAI,CAACE,YAAY,CAAC,CAAC;IACvB,CAAC,CAAC;IACFV,KAAK,CAACS,EAAE,CAAC,sFAAsF,EAAET,KAAK,CAACU,YAAY,CAAC;IACpH,IAAIX,MAAM,IAAIA,MAAM,CAAC,YAAY,CAAC,EAAE;MAChCjB,MAAM,CAACoB,IAAI,CAACS,IAAI,CAAC,0EAA0E,CAAC;MAC5FX,KAAK,CAACY,WAAW,CAACb,MAAM,CAAC,YAAY,CAAC,CAAC;IAC3C;IACAC,KAAK,CAACU,YAAY,CAAC,CAAC;IACpB,OAAOV,KAAK;EAChB;EACAnB,QAAQ,CAACT,SAAS,CAACyC,UAAU,GAAG,UAAUpB,OAAO,EAAE;IAC/CA,OAAO,CAACqB,OAAO,CAAC,MAAM,EAAE,IAAI,CAACC,eAAe,CAAC,CAAC,CAAC;IAC/CtB,OAAO,CAACqB,OAAO,CAAC,cAAc,EAAE,IAAI,CAACE,YAAY,CAAC,CAAC,CAAC;IACpDvB,OAAO,CAACqB,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC;IACpCrB,OAAO,CAACwB,IAAI,CAAC,CAAC;IACd,IAAIC,cAAc,GAAG,IAAI,CAACA,cAAc,CAAC,CAAC;IAC1C,IAAIC,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC;IACtB,IAAIC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;IAC9B,IAAIC,SAAS,GAAG,IAAI,CAACA,SAAS;IAC9B,IAAIH,cAAc,KAAK,WAAW,EAAE;MAChCzB,OAAO,CAAC6B,SAAS,CAAC,CAAC;IACvB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACvC9B,OAAO,CAACwB,IAAI,CAAC,CAAC;MACd,IAAIQ,EAAE,GAAGJ,SAAS,CAACE,CAAC,CAAC,CAACE,EAAE;MACxBhC,OAAO,CAACiC,SAAS,CAACD,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,CAAC;MAC7BnC,OAAO,CAACoC,MAAM,CAACR,SAAS,CAACE,CAAC,CAAC,CAACO,QAAQ,CAAC;MACrC,IAAI,CAACnC,WAAW,GAAG0B,SAAS,CAACE,CAAC,CAAC,CAACQ,IAAI;MACpCtC,OAAO,CAACuC,eAAe,CAAC,IAAI,CAAC;MAC7B,IAAId,cAAc,KAAK,WAAW,EAAE;QAChC,IAAIK,CAAC,KAAK,CAAC,EAAE;UACT9B,OAAO,CAACwC,MAAM,CAAC,CAAC,EAAEb,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;QACvC;QACA3B,OAAO,CAACyC,MAAM,CAACd,QAAQ,EAAEA,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;MAC9C;MACA3B,OAAO,CAAC0C,OAAO,CAAC,CAAC;IACrB;IACA,IAAIjB,cAAc,KAAK,WAAW,EAAE;MAChCzB,OAAO,CAAC2C,WAAW,GAAGjB,IAAI;MAC1B1B,OAAO,CAAC4C,SAAS,GAAGjB,QAAQ,GAAG,EAAE;MACjC3B,OAAO,CAAC6C,MAAM,CAAC,CAAC;IACpB;IACA7C,OAAO,CAAC0C,OAAO,CAAC,CAAC;EACrB,CAAC;EACDtD,QAAQ,CAACT,SAAS,CAACmE,QAAQ,GAAG,UAAU9C,OAAO,EAAE;IAC7CA,OAAO,CAAC6B,SAAS,CAAC,CAAC;IACnB,IAAID,SAAS,GAAG,IAAI,CAACA,SAAS;IAC9B,IAAIA,SAAS,CAACG,MAAM,IAAI,CAAC,EAAE;MACvB,IAAIC,EAAE,GAAGJ,SAAS,CAAC,CAAC,CAAC,CAACI,EAAE;MACxBhC,OAAO,CAACwC,MAAM,CAACR,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,CAAC;IAC9B;IACA,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACvC,IAAIiB,EAAE,GAAGnB,SAAS,CAACE,CAAC,CAAC,CAACiB,EAAE;MACxB/C,OAAO,CAACyC,MAAM,CAACM,EAAE,CAACb,CAAC,EAAEa,EAAE,CAACZ,CAAC,CAAC;IAC9B;IACAnC,OAAO,CAACqB,OAAO,CAAC,WAAW,EAAE,IAAI,CAACM,QAAQ,CAAC,CAAC,CAAC;IAC7C3B,OAAO,CAACqB,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC2B,QAAQ,CAAC;IAC7ChD,OAAO,CAAC6C,MAAM,CAAC,CAAC;EACpB,CAAC;EACDzD,QAAQ,CAACT,SAAS,CAACsE,YAAY,GAAG,YAAY;IAC1C,OAAO,IAAI,CAACC,SAAS;EACzB,CAAC;EACD9D,QAAQ,CAACT,SAAS,CAACwE,aAAa,GAAG,YAAY;IAC3C9D,MAAM,CAACoB,IAAI,CAACS,IAAI,CAAC,2HAA2H,CAAC;IAC7I,OAAO,IAAI,CAACkC,UAAU;EAC1B,CAAC;EACDhE,QAAQ,CAACT,SAAS,CAAC0E,OAAO,GAAG,UAAUf,IAAI,EAAE;IACzC,OAAO5C,MAAM,CAAC4D,IAAI,CAAC3E,SAAS,CAAC0E,OAAO,CAACxE,IAAI,CAAC,IAAI,EAAEyD,IAAI,CAAC;EACzD,CAAC;EACDlD,QAAQ,CAACT,SAAS,CAAC2C,eAAe,GAAG,YAAY;IAC7C,OAAO5B,MAAM,CAAC4D,IAAI,CAAC3E,SAAS,CAAC2C,eAAe,CAACzC,IAAI,CAAC,IAAI,CAAC;EAC3D,CAAC;EACDO,QAAQ,CAACT,SAAS,CAAC4E,YAAY,GAAG,UAAUjB,IAAI,EAAE;IAC9C,IAAI9B,WAAW,GAAG,IAAI,CAACA,WAAW;IAClC,IAAIgD,QAAQ,GAAGhD,WAAW,CAACiD,UAAU,CAAC,IAAI,CAAC;IAC3CD,QAAQ,CAAChC,IAAI,CAAC,CAAC;IACfgC,QAAQ,CAACE,IAAI,GAAG,IAAI,CAACpC,eAAe,CAAC,CAAC;IACtC,IAAIqC,OAAO,GAAGH,QAAQ,CAACI,WAAW,CAACtB,IAAI,CAAC;IACxCkB,QAAQ,CAACd,OAAO,CAAC,CAAC;IAClB,OAAO;MACHmB,KAAK,EAAEF,OAAO,CAACE,KAAK;MACpBC,MAAM,EAAEC,QAAQ,CAAC,IAAI,CAACjD,KAAK,CAACa,QAAQ,EAAE,EAAE;IAC5C,CAAC;EACL,CAAC;EACDvC,QAAQ,CAACT,SAAS,CAACsC,YAAY,GAAG,YAAY;IAC1C,IAAI+C,IAAI,GAAG,IAAI;IACf,IAAIC,IAAI,GAAG,IAAI,CAACV,YAAY,CAAC,IAAI,CAACzC,KAAK,CAACwB,IAAI,CAAC;IAC7C,IAAI4B,aAAa,GAAG,IAAI,CAACA,aAAa,CAAC,CAAC;IACxC,IAAIC,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;IACxB,IAAIhD,WAAW,GAAG,IAAI,CAACA,WAAW,CAAC,CAAC;IACpC,IAAI,CAAC+B,SAAS,GAAGe,IAAI,CAACJ,KAAK;IAC3B,IAAI,CAACT,UAAU,GAAGa,IAAI,CAACH,MAAM;IAC7B,IAAIM,aAAa,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACpB,SAAS,GAAG,CAAC,CAAC,IAAI,CAACpC,KAAK,CAACwB,IAAI,IAAI,EAAE,EAAEP,MAAM,GAAG,CAAC,IAAImC,aAAa,EAAE,CAAC,CAAC;IACtG,IAAI,CAACtC,SAAS,GAAG,EAAE;IACnB,IAAI2C,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,IAAI,CAACrD,SAAS,CAACoB,MAAM,EAAEyC,CAAC,EAAE,EAAE;MAC5C,IAAIR,IAAI,CAACrD,SAAS,CAAC6D,CAAC,CAAC,CAACC,UAAU,GAAG,CAAC,EAAE;QAClCF,aAAa,IAAIP,IAAI,CAACrD,SAAS,CAAC6D,CAAC,CAAC,CAACC,UAAU;MACjD;IACJ;IACA,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIP,KAAK,KAAK,QAAQ,EAAE;MACpBO,MAAM,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEC,aAAa,GAAG,CAAC,GAAGH,aAAa,GAAG,CAAC,CAAC;IAC/D;IACA,IAAID,KAAK,KAAK,OAAO,EAAE;MACnBO,MAAM,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEC,aAAa,GAAGH,aAAa,CAAC;IACvD;IACA,IAAIO,OAAO,GAAGjF,MAAM,CAACkF,aAAa,CAAC,IAAI,CAACtC,IAAI,CAAC,CAAC,CAAC;IAC/C,IAAIuC,YAAY,GAAG,IAAI,CAACvC,IAAI,CAAC,CAAC,CAACwC,KAAK,CAAC,GAAG,CAAC,CAAC/C,MAAM,GAAG,CAAC;IACpD,IAAIC,EAAE,EAAEe,EAAE,EAAEgC,OAAO;IACnB,IAAIC,MAAM,GAAG,CAAC,CAAC;IACf,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIC,kBAAkB,GAAG,SAAAA,CAAA,EAAY;MACjCD,QAAQ,GAAG,CAAC;MACZ,IAAIE,QAAQ,GAAGnB,IAAI,CAACrD,SAAS;MAC7B,KAAK,IAAIyE,CAAC,GAAGJ,MAAM,GAAG,CAAC,EAAEI,CAAC,GAAGD,QAAQ,CAACpD,MAAM,EAAEqD,CAAC,EAAE,EAAE;QAC/C,IAAID,QAAQ,CAACC,CAAC,CAAC,CAACX,UAAU,GAAG,CAAC,EAAE;UAC5BO,MAAM,GAAGI,CAAC;UACV,OAAOD,QAAQ,CAACC,CAAC,CAAC;QACtB,CAAC,MACI,IAAID,QAAQ,CAACC,CAAC,CAAC,CAACC,OAAO,KAAK,GAAG,EAAE;UAClCrD,EAAE,GAAG;YACDE,CAAC,EAAEiD,QAAQ,CAACC,CAAC,CAAC,CAACE,MAAM,CAAC,CAAC,CAAC;YACxBnD,CAAC,EAAEgD,QAAQ,CAACC,CAAC,CAAC,CAACE,MAAM,CAAC,CAAC;UAC3B,CAAC;QACL;MACJ;MACA,OAAO,CAAC,CAAC;IACb,CAAC;IACD,IAAIC,yBAAyB,GAAG,SAAAA,CAAUC,CAAC,EAAE;MACzC,IAAIC,UAAU,GAAGzB,IAAI,CAACT,YAAY,CAACiC,CAAC,CAAC,CAAC3B,KAAK,GAAGK,aAAa;MAC3D,IAAIsB,CAAC,KAAK,GAAG,IAAIrB,KAAK,KAAK,SAAS,EAAE;QAClCsB,UAAU,IAAI,CAAClB,aAAa,GAAGH,aAAa,IAAIS,YAAY;MAChE;MACA,IAAIa,OAAO,GAAG,CAAC;MACf,IAAIC,QAAQ,GAAG,CAAC;MAChB5C,EAAE,GAAG6C,SAAS;MACd,OAAOvB,IAAI,CAACwB,GAAG,CAACJ,UAAU,GAAGC,OAAO,CAAC,GAAGD,UAAU,GAAG,IAAI,IACrDE,QAAQ,GAAG,EAAE,EAAE;QACfA,QAAQ,EAAE;QACV,IAAIG,oBAAoB,GAAGJ,OAAO;QAClC,OAAOX,OAAO,KAAKa,SAAS,EAAE;UAC1Bb,OAAO,GAAGG,kBAAkB,CAAC,CAAC;UAC9B,IAAIH,OAAO,IACPe,oBAAoB,GAAGf,OAAO,CAACN,UAAU,GAAGgB,UAAU,EAAE;YACxDK,oBAAoB,IAAIf,OAAO,CAACN,UAAU;YAC1CM,OAAO,GAAGa,SAAS;UACvB;QACJ;QACA,IAAIb,OAAO,KAAK,CAAC,CAAC,IAAI/C,EAAE,KAAK4D,SAAS,EAAE;UACpC,OAAOA,SAAS;QACpB;QACA,IAAIG,cAAc,GAAG,KAAK;QAC1B,QAAQhB,OAAO,CAACM,OAAO;UACnB,KAAK,GAAG;YACJ,IAAI5F,MAAM,CAACmB,IAAI,CAACoF,aAAa,CAAChE,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAE4C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGG,UAAU,EAAE;cAC1F1C,EAAE,GAAGtD,MAAM,CAACmB,IAAI,CAACqF,cAAc,CAACR,UAAU,EAAEzD,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAE4C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEtD,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,CAAC;YAC7G,CAAC,MACI;cACD4C,OAAO,GAAGa,SAAS;YACvB;YACA;UACJ,KAAK,GAAG;YACJ,IAAIM,KAAK,GAAGnB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC;YAC7B,IAAIa,MAAM,GAAGpB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC;YAC9B,IAAIc,GAAG,GAAGrB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,GAAGa,MAAM;YACpC,IAAIlB,QAAQ,KAAK,CAAC,EAAE;cAChBA,QAAQ,GAAGiB,KAAK,GAAG,UAAU;YACjC,CAAC,MACI,IAAIT,UAAU,GAAGC,OAAO,EAAE;cAC3BT,QAAQ,IAAMZ,IAAI,CAACgC,EAAE,GAAG,KAAK,GAAIF,MAAM,GAAI9B,IAAI,CAACwB,GAAG,CAACM,MAAM,CAAC;YAC/D,CAAC,MACI;cACDlB,QAAQ,IAAMZ,IAAI,CAACgC,EAAE,GAAG,KAAK,GAAIF,MAAM,GAAI9B,IAAI,CAACwB,GAAG,CAACM,MAAM,CAAC;YAC/D;YACA,IAAKA,MAAM,GAAG,CAAC,IAAIlB,QAAQ,GAAGmB,GAAG,IAC5BD,MAAM,IAAI,CAAC,IAAIlB,QAAQ,GAAGmB,GAAI,EAAE;cACjCnB,QAAQ,GAAGmB,GAAG;cACdL,cAAc,GAAG,IAAI;YACzB;YACAhD,EAAE,GAAGtD,MAAM,CAACmB,IAAI,CAAC0F,uBAAuB,CAACvB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEL,QAAQ,EAAEF,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC;YACjJ;UACJ,KAAK,GAAG;YACJ,IAAIL,QAAQ,KAAK,CAAC,EAAE;cAChB,IAAIQ,UAAU,GAAGV,OAAO,CAACN,UAAU,EAAE;gBACjCQ,QAAQ,GAAG,UAAU;cACzB,CAAC,MACI;gBACDA,QAAQ,GAAGQ,UAAU,GAAGV,OAAO,CAACN,UAAU;cAC9C;YACJ,CAAC,MACI,IAAIgB,UAAU,GAAGC,OAAO,EAAE;cAC3BT,QAAQ,IAAI,CAACQ,UAAU,GAAGC,OAAO,IAAIX,OAAO,CAACN,UAAU,GAAG,CAAC;YAC/D,CAAC,MACI;cACDQ,QAAQ,GAAGZ,IAAI,CAACC,GAAG,CAACW,QAAQ,GAAG,CAACS,OAAO,GAAGD,UAAU,IAAIV,OAAO,CAACN,UAAU,GAAG,CAAC,EAAE,CAAC,CAAC;YACtF;YACA,IAAIQ,QAAQ,GAAG,GAAG,EAAE;cAChBA,QAAQ,GAAG,GAAG;cACdc,cAAc,GAAG,IAAI;YACzB;YACAhD,EAAE,GAAGtD,MAAM,CAACmB,IAAI,CAAC2F,qBAAqB,CAACtB,QAAQ,EAAEF,OAAO,CAACmB,KAAK,CAAChE,CAAC,EAAE6C,OAAO,CAACmB,KAAK,CAAC/D,CAAC,EAAE4C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC;YACpM;UACJ,KAAK,GAAG;YACJ,IAAIL,QAAQ,KAAK,CAAC,EAAE;cAChBA,QAAQ,GAAGQ,UAAU,GAAGV,OAAO,CAACN,UAAU;YAC9C,CAAC,MACI,IAAIgB,UAAU,GAAGC,OAAO,EAAE;cAC3BT,QAAQ,IAAI,CAACQ,UAAU,GAAGC,OAAO,IAAIX,OAAO,CAACN,UAAU;YAC3D,CAAC,MACI;cACDQ,QAAQ,IAAI,CAACS,OAAO,GAAGD,UAAU,IAAIV,OAAO,CAACN,UAAU;YAC3D;YACA,IAAIQ,QAAQ,GAAG,GAAG,EAAE;cAChBA,QAAQ,GAAG,GAAG;cACdc,cAAc,GAAG,IAAI;YACzB;YACAhD,EAAE,GAAGtD,MAAM,CAACmB,IAAI,CAAC4F,yBAAyB,CAACvB,QAAQ,EAAEF,OAAO,CAACmB,KAAK,CAAChE,CAAC,EAAE6C,OAAO,CAACmB,KAAK,CAAC/D,CAAC,EAAE4C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC;YAClK;QACR;QACA,IAAIvC,EAAE,KAAK6C,SAAS,EAAE;UAClBF,OAAO,GAAGjG,MAAM,CAACmB,IAAI,CAACoF,aAAa,CAAChE,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAEY,EAAE,CAACb,CAAC,EAAEa,EAAE,CAACZ,CAAC,CAAC;QAC/D;QACA,IAAI4D,cAAc,EAAE;UAChBA,cAAc,GAAG,KAAK;UACtBhB,OAAO,GAAGa,SAAS;QACvB;MACJ;IACJ,CAAC;IACD,IAAIa,QAAQ,GAAG,GAAG;IAClB,IAAIhB,UAAU,GAAGzB,IAAI,CAACT,YAAY,CAACkD,QAAQ,CAAC,CAAC5C,KAAK,GAAGK,aAAa;IAClE,IAAIwC,eAAe,GAAGhC,MAAM,GAAGe,UAAU,GAAG,CAAC;IAC7C,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,eAAe,EAAEC,CAAC,EAAE,EAAE;MACtCpB,yBAAyB,CAACkB,QAAQ,CAAC;MACnC,IAAIzE,EAAE,KAAK4D,SAAS,IAAI7C,EAAE,KAAK6C,SAAS,EAAE;QACtC;MACJ;MACA5D,EAAE,GAAGe,EAAE;IACX;IACA,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,OAAO,CAAC5C,MAAM,EAAED,CAAC,EAAE,EAAE;MACrCyD,yBAAyB,CAACZ,OAAO,CAAC7C,CAAC,CAAC,CAAC;MACrC,IAAIE,EAAE,KAAK4D,SAAS,IAAI7C,EAAE,KAAK6C,SAAS,EAAE;QACtC;MACJ;MACA,IAAI/B,KAAK,GAAGpE,MAAM,CAACmB,IAAI,CAACoF,aAAa,CAAChE,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAEY,EAAE,CAACb,CAAC,EAAEa,EAAE,CAACZ,CAAC,CAAC;MAC7D,IAAIyE,IAAI,GAAG,CAAC;MACZ,IAAIzF,WAAW,EAAE;QACb,IAAI;UACAyF,IAAI,GAAGzF,WAAW,CAACwD,OAAO,CAAC7C,CAAC,GAAG,CAAC,CAAC,EAAE6C,OAAO,CAAC7C,CAAC,CAAC,CAAC,GAAG,IAAI,CAACH,QAAQ,CAAC,CAAC;QACpE,CAAC,CACD,OAAOkF,CAAC,EAAE;UACND,IAAI,GAAG,CAAC;QACZ;MACJ;MACA5E,EAAE,CAACE,CAAC,IAAI0E,IAAI;MACZ7D,EAAE,CAACb,CAAC,IAAI0E,IAAI;MACZ,IAAI,CAAC1D,SAAS,IAAI0D,IAAI;MACtB,IAAIE,QAAQ,GAAGrH,MAAM,CAACmB,IAAI,CAACqF,cAAc,CAACW,IAAI,GAAG/C,KAAK,GAAG,GAAG,EAAE7B,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAEY,EAAE,CAACb,CAAC,EAAEa,EAAE,CAACZ,CAAC,CAAC;MACrF,IAAIE,QAAQ,GAAGgC,IAAI,CAAC0C,KAAK,CAAChE,EAAE,CAACZ,CAAC,GAAGH,EAAE,CAACG,CAAC,EAAEY,EAAE,CAACb,CAAC,GAAGF,EAAE,CAACE,CAAC,CAAC;MACnD,IAAI,CAACN,SAAS,CAACoF,IAAI,CAAC;QAChBC,UAAU,EAAEH,QAAQ,CAAC5E,CAAC;QACtBgF,UAAU,EAAEJ,QAAQ,CAAC3E,CAAC;QACtBG,IAAI,EAAEqC,OAAO,CAAC7C,CAAC,CAAC;QAChBO,QAAQ,EAAEA,QAAQ;QAClBL,EAAE,EAAEA,EAAE;QACNe,EAAE,EAAEA;MACR,CAAC,CAAC;MACFf,EAAE,GAAGe,EAAE;IACX;EACJ,CAAC;EACD3D,QAAQ,CAACT,SAAS,CAACwI,WAAW,GAAG,YAAY;IACzC,IAAI,CAAC,IAAI,CAACvF,SAAS,CAACG,MAAM,EAAE;MACxB,OAAO;QACHG,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,CAAC;QACJ0B,KAAK,EAAE,CAAC;QACRC,MAAM,EAAE;MACZ,CAAC;IACL;IACA,IAAIwB,MAAM,GAAG,EAAE;IACf,IAAI,CAAC1D,SAAS,CAACwF,OAAO,CAAC,UAAUC,IAAI,EAAE;MACnC/B,MAAM,CAAC0B,IAAI,CAACK,IAAI,CAACrF,EAAE,CAACE,CAAC,CAAC;MACtBoD,MAAM,CAAC0B,IAAI,CAACK,IAAI,CAACrF,EAAE,CAACG,CAAC,CAAC;MACtBmD,MAAM,CAAC0B,IAAI,CAACK,IAAI,CAACtE,EAAE,CAACb,CAAC,CAAC;MACtBoD,MAAM,CAAC0B,IAAI,CAACK,IAAI,CAACtE,EAAE,CAACZ,CAAC,CAAC;IAC1B,CAAC,CAAC;IACF,IAAImF,IAAI,GAAGhC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,IAAIiC,IAAI,GAAGjC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,IAAIkC,IAAI,GAAGlC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,IAAImC,IAAI,GAAGnC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,IAAIpD,CAAC,EAAEC,CAAC;IACR,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwD,MAAM,CAACvD,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;MACxCI,CAAC,GAAGoD,MAAM,CAACxD,CAAC,GAAG,CAAC,CAAC;MACjBK,CAAC,GAAGmD,MAAM,CAACxD,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MACrBwF,IAAI,GAAGjD,IAAI,CAACqD,GAAG,CAACJ,IAAI,EAAEpF,CAAC,CAAC;MACxBqF,IAAI,GAAGlD,IAAI,CAACC,GAAG,CAACiD,IAAI,EAAErF,CAAC,CAAC;MACxBsF,IAAI,GAAGnD,IAAI,CAACqD,GAAG,CAACF,IAAI,EAAErF,CAAC,CAAC;MACxBsF,IAAI,GAAGpD,IAAI,CAACC,GAAG,CAACmD,IAAI,EAAEtF,CAAC,CAAC;IAC5B;IACA,IAAIR,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC,CAAC;IAC9B,OAAO;MACHO,CAAC,EAAEoF,IAAI,GAAG3F,QAAQ,GAAG,CAAC;MACtBQ,CAAC,EAAEqF,IAAI,GAAG7F,QAAQ,GAAG,CAAC;MACtBkC,KAAK,EAAE0D,IAAI,GAAGD,IAAI,GAAG3F,QAAQ;MAC7BmC,MAAM,EAAE2D,IAAI,GAAGD,IAAI,GAAG7F;IAC1B,CAAC;EACL,CAAC;EACD,OAAOvC,QAAQ;AACnB,CAAC,CAACI,OAAO,CAACmI,KAAK,CAAE;AACjBzI,OAAO,CAACE,QAAQ,GAAGA,QAAQ;AAC3BA,QAAQ,CAACT,SAAS,CAACoB,SAAS,GAAGA,SAAS;AACxCX,QAAQ,CAACT,SAAS,CAACwB,WAAW,GAAGA,WAAW;AAC5Cf,QAAQ,CAACT,SAAS,CAACiJ,YAAY,GAAG7H,SAAS;AAC3CX,QAAQ,CAACT,SAAS,CAACkJ,cAAc,GAAG1H,WAAW;AAC/Cf,QAAQ,CAACT,SAAS,CAACmJ,SAAS,GAAG,UAAU;AACzC1I,QAAQ,CAACT,SAAS,CAACoJ,mBAAmB,GAAG,CAAC,MAAM,EAAE,UAAU,EAAE,MAAM,CAAC;AACrEnI,QAAQ,CAACoI,aAAa,CAAC5I,QAAQ,CAAC;AAChCG,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,MAAM,CAAC;AACnDG,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC;AAClEG,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,UAAU,EAAE,EAAE,EAAEO,YAAY,CAACwI,kBAAkB,CAAC,CAAC,CAAC;AAC9F5I,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,WAAW,EAAEU,MAAM,CAAC;AAChEP,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC;AAC5DG,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,eAAe,EAAE,CAAC,EAAEO,YAAY,CAACwI,kBAAkB,CAAC,CAAC,CAAC;AAClG5I,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,cAAc,EAAE,QAAQ,CAAC;AACrEG,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,aAAa,EAAEU,MAAM,CAAC;AAClEP,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,MAAM,EAAES,YAAY,CAAC;AACjEN,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,gBAAgB,EAAE,IAAI,CAAC;AACnEG,SAAS,CAAC0I,OAAO,CAACC,eAAe,CAAC9I,QAAQ,EAAE,aAAa,EAAE,IAAI,CAAC;AAChEC,MAAM,CAAC+I,UAAU,CAACC,UAAU,CAACjJ,QAAQ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}